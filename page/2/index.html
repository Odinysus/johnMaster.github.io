<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>John</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="John">
<meta property="og:url" content="http://johnmaster.com/page/2/index.html">
<meta property="og:site_name" content="John">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="John">
  
    <link rel="alternative" href="/atom.xml" title="John" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John Doe</a></h1>
		</hgroup>

		
		<p class="header-subtitle">a flying white kite</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">John Doe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="null" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">John Doe</h1>
			</hgroup>
			
			<p class="header-subtitle">a flying white kite</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-vim插件安装以及使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/vim插件安装以及使用/">vim插件安装以及使用.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>vim是个很强大的文本编辑器,不仅是因为它能让我们完全抛弃使用键盘,而且拥有强大的扩展性,可以添加任何各种各样的插件.只要你所想到的,基本能在网上找到想对应的插件.</p>
<h4 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h4><p>Vundle是vim上的插件管理器.只需要在<code>.vimrc</code>添加上控件名,Vundle可以帮我们下载到插件文件夹<code>/Users/{username}/.vim/bundle</code>中.<br>有一个vim插件的资源网站,可以在那里搜索:<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">vim scripts</a></p>
<ol>
<li>clone Vundle ,在输入一下命令<br> cd ~/.vim/bundle<br> git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="external">https://github.com/VundleVim/Vundle.vim.git</a>  </li>
<li>输入<br> git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="external">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim  </li>
<li><p>修改配置文件<code>.vimrc</code>  </p>
<pre><code>set nocompatible              
filetype off                 

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

&quot; 从这里开始,end之前.添加你想要的插件,可以从本地,github,git,Vim Scripts中加载插件&quot;
Plugin &apos;VundleVim/Vundle.vim&apos;
Plugin &apos;tpope/vim-fugitive&apos;
Plugin &apos;rstacruz/sparkup&apos;, {&apos;rtp&apos;: &apos;vim/&apos;}

call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; 然后这里开始添加vim的其他配置
</code></pre></li>
</ol>
<p>添加插件之后(w保存),你可以使用<code>PluginList</code>查看当前配置中的插件列表<br><img src="https://cl.ly/2g0R1k3G3x0H/download/Screen%20Shot%202016-09-04%20at%206.11.14%20PM.png" alt="插件列表"><br>每当添加新的控件之后都要执行<code>PluginInstall</code>安装插件</p>
<p>其他常用命令  </p>
<pre><code>:BundleList              -列举列表(也就是.vimrc)中配置的所有插件
:BundleInstall          -安装列表中的全部插件
:BundleInstall!         -更新列表中的全部插件
:BundleSearch foo   -查找foo插件
:BundleSearch! foo  -刷新foo插件缓存
:BundleClean           -清除列表中没有的插件
:BundleClean!          -清除列表中没有的插件
</code></pre><h4 id="EasyMotion"><a href="#EasyMotion" class="headerlink" title="EasyMotion"></a>EasyMotion</h4><p>高级的vim移动方式.<br>可以帮助你跳转到特定的单词中,而不必一个一个数要向前或向后跳多少个单词.<br>主要有两个用途:</p>
<ol>
<li>跳转某个特定单词.   </li>
<li>跳转某一特定的行.  </li>
</ol>
<p>安装:</p>
<pre><code>Plugin &apos;EasyMotion&apos;  
</code></pre><p>设置  </p>
<pre><code>let g:EasyMotion_leader_key = &apos;{keyword}&apos;
</code></pre><p>我将快捷键绑定为大写<code>W</code>,假如我跳转到后面的单词,敲键盘<code>W</code>和w,会显示多个选项.<br><img src="https://cl.ly/3O0y2W2t0003/download/Image%202016-09-04%20at%206.28.18%20PM.png" alt="key"><br>让后根据提示输入对应字母就能跳转到其单词.<br>如果碰到当前超过48个单词,则会有一些相同的字母,输入之后.会跳转到第一个并从新生成字母索引.</p>
<h3 id="neocomplcache"><a href="#neocomplcache" class="headerlink" title="neocomplcache"></a>neocomplcache</h3><p>自动补全插件,与此类似还有另外一个插件autocomplete.autocomplete对ruby的支持很差,经常卡死.<br>这个版本是带缓存版本.<br>安装:  </p>
<pre><code>Plugin `neocomplcache`
</code></pre><p>设置:  </p>
<pre><code>let g:neocomplcache_enable_at_startup = 1
let g:neocomplcache_min_keyword_length = 3 &quot; 从第三个字符开始语法提示
let g:neocomplcache_enable_smart_case = 1&quot; 区分大小写
</code></pre><p>为了保险起见,在配置完成之后需要在vim中输入一下命令<code>NeoComplCacheEnable</code></p>
<p>特别地,针对ruby,还需要一下配置  </p>
<pre><code>autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
if !exists(&apos;g:neocomplcache_force_omni_patterns&apos;)
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_force_omni_patterns.ruby = &apos;[^. *\t]\.\w*\|\h\w*::&apos;
</code></pre><h3 id="Syntastic"><a href="#Syntastic" class="headerlink" title="Syntastic"></a>Syntastic</h3><p>语法审核和语法错误提示.这个可以实时检测语法并可以高亮其错误.插件本身不自带语法检查器,其中一部分利用系统的检查器,其他的需要自己下载.<br><img src="https://github.com/scrooloose/syntastic/raw/master/_assets/screenshot_1.png" alt="Syntastic"></p>
<p>安装  </p>
<pre><code>Plugin &apos;Syntastic&apos;
</code></pre><p>配置</p>
<pre><code>set statusline+=%#warningmsg#       &quot; 状态栏警告信息
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

&quot; 语法分析
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1   &quot; 自动显示错误信息,无错误时隐藏
let g:syntastic_check_on_open = 1   &quot; 打开时检测
let g:syntastic_check_on_wq = 1     &quot; 保存时检查
let g:syntastic_ruby_exec = &apos;ruby&apos;  // 设置ruby检查器
let g:syntastic_rb_checker = &apos;mri&apos;   &quot; 设置rb格式检查器为mri
</code></pre><h3 id="vim-powerline"><a href="#vim-powerline" class="headerlink" title="vim - powerline"></a>vim - powerline</h3><p>使用与vim的一个更加酷炫的状态栏<br><img src="https://camo.githubusercontent.com/63f9947cac196ec7e6e3d790fd3cd1e1463a7b9b/687474703a2f2f692e696d6775722e636f6d2f4d737549422e706e67" alt="powerline"></p>
<p>安装<br>这个插件并没有托管在<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">vim scripts</a>上,所以直接从github下载</p>
<pre><code>Plugin &apos;https://github.com/Lokaltog/vim-powerline.git&apos;
</code></pre><p>配置</p>
<pre><code>set nocompatible   &quot; 不向下兼容
set laststatus=2   &quot; Always show the statusline
set encoding=utf-8 &quot; Necessary to show Unicode glyphs
let g:Powerline_symbols = &apos;unicode&apos;
let g:Powerline_colorscheme = &apos;solarized256&apos;
let g:Powerline_stl_path_style = &apos;short&apos;
set t_Co=256
</code></pre><h3 id="nerdtree"><a href="#nerdtree" class="headerlink" title="nerdtree"></a>nerdtree</h3><p>nrdtree可以在当前vim中分割一个小窗口查看文件目录,如果我们在ruby或python的项目中使用vim,可能需要频繁得打开很多文件.需要查看文件目录查找文件.<br><img src="https://cl.ly/3y2U1A0t2V3P/download/Image%202016-09-06%20at%201.45.31%20PM.png" alt="nerdtree"><br>打开时默认打开当前文件所在的目录.</p>
<p>安装  </p>
<pre><code>Plugin &apos;The-NERD-tree&apos;
</code></pre><p>配置</p>
<pre><code>&quot; 如果当前没文件时,自动打开
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 &amp;&amp; !exists(&quot;s:std_in&quot;) | NERDTree | endif

map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;  &quot; 映射`ctrl+c`快捷键
let g:nerdtree_tabs_smart_startup_focus = 1     
let NERDTreeAutoCenter=1       &quot; nerdtree 光标所在的位置默认在窗口中间
let NERDTreeWinPos = &apos;right&apos;   &quot; nerdtree 窗口显示在右边
</code></pre><h3 id="cocoa-vim"><a href="#cocoa-vim" class="headerlink" title="cocoa.vim"></a>cocoa.vim</h3><p>vim下的cocoa扩展.官方文档<a href="http://www.vim.org/scripts/script.php?script_id=2674" target="_blank" rel="external">cocoa.vim</a><br>主要特性:  </p>
<ul>
<li>增强代码高亮   </li>
<li>xcode式快捷键–⌘R 编译和运行, ⌘0切换项目窗口(只在GUI界面生效)  </li>
<li>在<code>.m</code>文件中输入<code>:ListMethods</code>命令可以显示文件夹的方法列表</li>
<li>在<code>.m</code>文件中输入<code>:BuildMethods</code>命令可以在<code>.h</code>文件中生成对应的声明方法  </li>
<li>输入<code>:CocoaDoc</code>命令查看文档  </li>
</ul>
<p>使用vim自带的高亮:<br><img src="https://cl.ly/1b0Y0B1J2e1M/download/Image%202016-09-30%20at%203.48.59%20AM.png" alt="cocoa.vim-before"></p>
<p>使用cocoa.vim中的高亮,增强不多,但聊胜于无:<br><img src="https://cl.ly/3D0v3k43423n/download/Image%202016-09-30%20at%203.09.16%20AM.png" alt="cocoa.vim-after"></p>
<p>安装:  </p>
<pre><code>Plugin &apos;cocoa.vim&apos;
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>文件地址下载: <a href="https://cl.ly/1R0V3I0y0f0I" target="_blank" rel="external">.vimrc</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/vim插件安装以及使用/" class="archive-article-date">
  	<time datetime="2016-10-19T18:13:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-iOS-字典转字符串的格式问题(iOS-wrong-format-of-json-string)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS-字典转字符串的格式问题(iOS-wrong-format-of-json-string)/">iOS-字典转字符串的格式问题(iOS-wrong-format-of-json-string).md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在调用接口上传数据时,有时候需要将一个字典或一个数组转换成json串,并作为一个普通的参数.<br>使用<code>NSJSONSerialization</code>对其进行转换:    </p>
<pre><code>NSDictionary *dic = @{@&quot;appid&quot;:@&quot;103905&quot;, @&quot;tokenid&quot;:@&quot;1&quot;, @&quot;version&quot;:@&quot;1&quot;, @&quot;sign&quot;:@&quot;1&quot;};
NSData *JSONData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:nil];
NSString *str = [[NSString alloc] initWithData:JSONData encoding:NSUTF8StringEncoding];
</code></pre><p>大多数情况下,我们都是按照以上方法转换.但是我发现 <strong>转换后的字符串中有<code>\n</code>符号</strong>.这导致了参数数据设置不成功.  </p>
<pre><code>@&quot;{\n  \&quot;tokenid\&quot; : \&quot;1\&quot;,\n  \&quot;appid\&quot; : \&quot;103905\&quot;,\n  \&quot;sign\&quot; : \&quot;1\&quot;,\n  \&quot;version\&quot; : \&quot;1\&quot;\n}&quot;      
</code></pre><p>经过尝试后发现,这是一个参数的设置问题:</p>
<pre><code>`NSJSONWritingPrettyPrinted`
</code></pre><p>这个参数的意思是转换将字典装换成打印之后跟适合阅读的字符串,结果在字符串中添加了<code>\n</code>符. <strong>将这个参数成0</strong>,就不会再字符串中添加换行符了.</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://stackoverflow.com/questions/19314135/ios-runtime-use-case" target="_blank" rel="external">http://stackoverflow.com/questions/19314135/ios-runtime-use-case</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/iOS-字典转字符串的格式问题(iOS-wrong-format-of-json-string)/" class="archive-article-date">
  	<time datetime="2016-10-19T18:12:39.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-UITableViewCell的复用机制(UITableViewCell reuse mechanism)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UITableViewCell的复用机制(UITableViewCell reuse mechanism)/">UITableViewCell的复用机制(UITableViewCell reuse mechanism).md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>UITableview在iOS中的使用频率是非常高的.通常,我们只需要通过设置代理,并且在代理方法<br><code>tableView:cellForRowAtIndexPath:</code> 调用 <code>dequeueReusableCellWithIdentifier:</code>获取cell并直接使用.<br>但是从没有细致得想过其中的过程与机制,并且<br>知道最近面试(此次面试的问题)的时候,才发现自己表述得不太好.这种情况就好像你每天都准时吃放(滑稽),突然有一天有人问你人为什么吃放的时候自己却没能即使答上来的那种感觉.<br>说明自己掌握得不够扎实.as we know,  </p>
<blockquote>
<p>如果你不能将知识通过简洁的语言表达出来,那说明你还没掌握这个知识.</p>
</blockquote>
<p>借此机会,将这个知识点记录下来</p>
<h3 id="reuseIdentifier"><a href="#reuseIdentifier" class="headerlink" title="reuseIdentifier"></a>reuseIdentifier</h3><p>对于reuseIdentifier,<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewCell_Class/index.html#//apple_ref/occ/instp/UITableViewCell/reuseIdentifier" target="_blank" rel="external">官方文档</a>是这样解释的:  </p>
<blockquote>
<p>The reuse identifier is associated with a <code>UITableViewCell</code> object that<br> the table-view’s delegate creates with the intent to reuse it<br>  as the basis (for performance reasons) for multiple rows of a table view.<br>   It is assigned to the cell object in <code>initWithFrame:reuseIdentifier:</code> and cannot be changed thereafter.<br>    A <code>UITableView</code> object maintains a queue (or list) of the currently reusable cells,<br>    each with its own reuse identifier,<br>    and makes them available to the delegate in the <code>dequeueReusableCellWithIdentifier:</code> method.</p>
</blockquote>
<p>冒死翻译一下:<br>这个复用标识关联<code>UITableviewCell</code>对象,在<code>tableview</code>代理中创建带有”标识符”来复用<code>cell</code>对象,而且作为<code>tableview</code>多行显示的原型(性能的原因).<br>通过<code>initWithFrame:reuseIdentifier:</code>来指定一个<code>cell</code>对象而且在调用这个方法之后就不能修改了.在<code>UITableView</code>对象维护一个当前复用的<code>cell</code>队列(或列表),<br>并且每一个<code>cell</code>都拥有自己的标识符,并这些<code>cell</code>能在代理对象的<code>dequeueReusableCellWithIdentifier:</code>的方法中获取.  </p>
<p>在tableview新建的时候,会新建一个复用池(reuse pool).这个复用池可能是一个队列,或者是一个链表,保存着当前的<code>Cell</code>.pool中的对象的复用标识符就是reuseIdentifier,标识着不同的种类的<code>cell</code>.<br>所以调用<code>dequeueReusableCellWithIdentifier:</code>方法获取<code>cell</code>.从pool中取出来的<code>cell</code>都是<code>tableview</code>展示的原型.无论之前有什么状态,全部都要设置一遍.  </p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>在<code>UITableView</code>创建同事,会创建一个空的复用池.之后<code>UITableView</code>在内部维护这个复用池.<br>一般情况下,有两种用法,一种是在取出一个空的cell的时候再新建一个.<br>一种是预先注册cell.之后再直接从复用池取出来用,不需要初始化.  </p>
<ul>
<li><p><code>UITableview</code>第一次执行<code>tableView:cellForRowAtIndexPath:</code>.当前复用池为空.<br><code>dequeueReusableCellWithIdentifier</code>调用中取出<code>cell</code>,并检测<code>cell</code>是否存在.<br>目前并不存在任何<code>cell</code>,于是新建一个<code>cell</code>,执行初始化, 并<code>return cell</code>.<br>代码如下:</p>
<pre><code>#define kInputCellReuseIdentifierPWD   @&quot;password_cell&quot;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kInputCellReuseIdentifierPWD];
if (!cell) {
    cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:kInputCellReuseIdentifierPWD];
    // other initialization i.e. add an UIButton to cell&apos;s contentView
}
// custom cell. i.e. change cell&apos;s title
cell.textLabel.text = @&quot;It is awesome&quot;;
return cell;
</code></pre></li>
</ul>
<p>上面的代码中,你返回的cell会被<code>UITableView</code>添加到复用池中.第二次调用<code>tableView:cellForRowAtIndexPath:</code>,当前复用池中有一个<code>cell</code>.这时候因为<code>UITableView</code>上面还未填满,而且复用池中唯一的那一个已经在使用了.<br>所以取出来的Cell仍然是nil.于是继续新建一个cell并返回,复用池再添加一个<code>cell</code>,当前复用池中<code>cell</code>的个数为2.<br>假如当前<code>tableview</code>只能容纳5个cell.那么在滚动到第6个cell时,从<code>tableview</code>的复用池取出来的<code>cell</code>将会是第0行的那个<code>cell</code>.此时不再继续往复用池添加新的cell.  </p>
<ul>
<li><p>另一个用法:在<code>UITableView</code>初始化的时候,注册一个<code>UITableViewCell</code>的类.</p>
<pre><code>[tableView registerClass:[UITableViewCell class]
         forCellWithReuseIdentifier:@&quot;AssetCell&quot;];
</code></pre></li>
</ul>
<p>使用此方法之后,就不用再判断取出来的<code>cell</code>是否为空,因为取出来的cell必定存在.调用<code>dequeueReusableCellWithIdentifier:</code>方法时,会先判断当前复用池时候有可用复用<code>cell</code>.<br>如果没有,<code>tableview</code>会再内部帮我们新建一个<code>cell</code>,其他的跟方法一样.<br>这里有个动画可以很清晰地看到滑动时的复用过程.  </p>
<video id="video" controls preload="none" poster="https://cl.ly/1F0V040u2C3y/Screen%20Shot%202016-08-25%20at%203.18.23%20PM.png"><br>      <source id="mp4" src="https://cl.ly/3k0m1W2P0X3y/table-view-cell-reuse-simulation.mp4" type="video/mp4"><br>      <p>Your user agent does not support the HTML5 Video element.</p><br>    </video>

<h3 id="爬过的坑"><a href="#爬过的坑" class="headerlink" title="爬过的坑"></a>爬过的坑</h3><p>从复用池中获取cell的方法有两个:<code>dequeueReusableCellWithIdentifier:forIndexPath:</code><br>和<code>dequeueReusableCellWithIdentifier:</code>.<br>还记得我们在第二个方法对使用使用复用池之前的情况吗? 对,就是注册一个cell.注册之后我们调用<code>dequeueReusableCellWithIdentifier:</code>获取cell.<br>对于第二种情况,两种方法都是没问题的.但是,在调用<code>registerClass:forCellReuseIdentifier:</code>之前,你必须注册一个cell类.正如<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/index.html#//apple_ref/occ/instm/UITableView/dequeueReusableCellWithIdentifier:forIndexPath:" target="_blank" rel="external">官方文档</a>所言:</p>
<blockquote>
<p>IMPORTANT<br>You must register a class or nib file using the <code>registerNib:forCellReuseIdentifier:</code> or <code>registerClass:forCellReuseIdentifier:</code> method before calling this method.</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>UITableViewCell</code>的复用机制是,在tableview中存在一个复用池.这个复用池是一个队列或一个链表.然后通过<code>dequeueReusableCellWithIdentifier:</code>获取一个<code>cell</code>,如果当前<code>cell</code>不存在,即新建一个cell,并将当前cell添加进复用池中.如果当前的cell数量已经到过tableview所能容纳的个数,则会在滚动到下一个<code>cell</code>时,自动取出之前的<code>cell</code>并设置内容.</p>
<h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>对象池设计模式</p>
<blockquote>
<p>The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use – a “pool” – rather than allocating and destroying them on demand. A client of the pool will request an object from the pool and perform operations on the returned object. When the client has finished, it returns the object to the pool rather than destroying it; this can be done manually or automatically.  —- <a href="https://en.wikipedia.org/wiki/Creational_pattern" target="_blank" rel="external">wikipedia</a>  </p>
</blockquote>
<p>大意是,对象池模式是一种创造型设计模式,使用一个已初始化对象的集合,并能随时从”池”中拿出来使用.以此避免对象的创建销毁所带来的开销.一个客户端的池会请求池中的对象,然后执行并在返回的对象上执行操作.当这个客户端结束时,代替原本销毁操作,取而代之的是将对象返回到池中.这个操作可以手动执行,也可以自动的执行.<br>有一个明显的有点就是面对数据量很大时,能很好的改善性能.  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://en.wikipedia.org/wiki/Object_pool_pattern" target="_blank" rel="external">Object pool pattern</a><br><a href="http://oleb.net/blog/2014/05/scrollviews-inside-scrollviews/" target="_blank" rel="external">Scroll Views Inside Scroll Views</a><br><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/index.html#//apple_ref/occ/intf/UITableViewDataSource" target="_blank" rel="external">UITableViewDataSource Protocol Reference</a><br><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/index.html" target="_blank" rel="external">UITableView</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/UITableViewCell的复用机制(UITableViewCell reuse mechanism)/" class="archive-article-date">
  	<time datetime="2016-10-19T18:10:10.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JazzHands框架使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/JazzHands框架使用/">JazzHands框架使用.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>OC版  <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">https://github.com/IFTTT/JazzHands</a><br>     switf版 <a href="https://github.com/IFTTT/RazzleDazzle" target="_blank" rel="external">https://github.com/IFTTT/RazzleDazzle</a></p>
</blockquote>
<ol>
<li>简介<br> Jazz Hand是一个简单的基于keyframe的UIKit动画框架。动画可以通过手势，scrollviews，Kvo或者ReactiveCocoa控制。  </li>
<li><p>安装<br> OC版:  </p>
<pre><code>pod &quot;JazzHands&quot;
</code></pre><p> swift版:  </p>
<pre><code>pod &quot;RazzleDazzle&quot;
</code></pre></li>
<li><p>类图<br><img src="https://cl.ly/2U1G2c3o2G3j/download/Class%20Diagram.png" alt="jazzhand"></p>
<p><strong>IFTTTAnimatior</strong><br>导演类,里面有一个动画(<code>IFTTTAnimation</code>)数组管理所有动画的添加\删除\执行.  </p>
<p><strong>IFTTTAnimatable</strong><br>执行动画类.<br>重要: 定义了核心协议,<code>animate:(CGFloat)time;</code> 计算每一个时间点当前对象的值.每一种动画都要实现这个借口.如<code>IFTTTAlphaAnimation</code>类,计算一个时间点对应的对象的alpha值,</p>
<p><strong>IFTTTAnimation</strong><br>动画基类,定义了一个对象的动画.类中有个<code>IFTTTFilemstrip</code>,用于管理动画的每一帧,设置和获取对应时间的关键帧动画的值.</p>
<blockquote>
<p>注: 每种动画都继承IFTTTAnimation和实现<iftttanimatable>协议才会正常工作.</iftttanimatable></p>
</blockquote>
<p><strong>IFTTTFilmstrip</strong><br>胶片类,有一个关键帧(IFTTTKeyframe)数组.,添加/修改/获取对应关键帧(IFTTTKeyframe)的值.通过valueAtTime:可以计算两个相邻关键帧之间的的值.这个值提供给animate使用.</p>
<p><strong>IFTTTKeyframe</strong><br>关键帧类,描述每一个关键帧的时间对应的值.  </p>
</li>
<li><p>分析:<br>jazzhand之应用在<code>scrollviews</code>,同时封装了<code>IFTTTAnimatedPagingScrollViewController</code>方便我们继承使用.目前这个类<code>scrollview</code>只支持横向滚动,并不支持纵向滚动.jazzhand框架是基于关键帧的动画,这个概念其实跟<code>Core Animation</code> 的概念是一样的. 只不过跟core Animation有不同一点的是,jazzhand框架的动画驱动是坐标驱动.<br>举个例子,在<code>Core Animation</code>中,我们只需要设置轨迹,方向,时间就可以提交了.接下就由<code>Core Animation</code>负责计算,就可以看到App能执行一段动画.这里设置了时间5s.在APP接下来的5s中,<code>Core Animation</code>每1/30秒重新计算一次<code>imageview</code>的位置并调用<code>[self ifNeedLayout]</code>方法进行更行.然后就形成了我们所看到的动画.</p>
<pre><code>  [UIView beginAnimations:@&quot;jk&quot; context:nil];
//    设置动画的方向
    [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:imageView cache:YES];
//    设置动画持续时间
    [UIView setAnimationDuration:5];
//   设置动画效果过渡的状态
    [UIView setAnimationCurve:UIViewAnimationCurveEaseIn];
//    提交动画
    [UIView commitAnimations];
}
</code></pre><p>但是Jazzhand中,却以<code>scrollview</code>的偏移值offset作为动画执行的time,在<code>[scrollview didScroll]</code>代理中重新计算视图的位置.<br><img src="https://cl.ly/2G3C1y170g3o/download/x-zhou.png" alt="坐标位移"><br>以上,坐标值表示scrollview的page页,同时也理解为时间time, time = 1 表示当前scrollview向右移动到offset=(pageWidth * 1),即滚到第二页的时候.所以可以想象每拖动一个页面,相当于view对象进行时间0到1的动画<br>每一个动画管理类(animator)都会拥有很多袋胶卷(filmstrip),每一个胶卷都包含该了该动作的所有关键帧(keyframe).随着右移,框架会根据约束和时间(offset)计算对象的位置.只要刷新的频率只够高.我们人眼就看不出是重新计算.而是连续的动画了.</p>
</li>
<li><p>使用:</p>
<ol>
<li><pre><code>@interface IntrotductionController:IFTTTAnimatedPagingScrollViewController
</code></pre><p><code>IFTTTAnimatedPagingScrollViewController</code><br>继承<code>viewcontroller</code>,有子成员<code>scrollview</code>,封装了<code>contentview</code>.所以只需要将对象加入到<code>contentview</code>中就可以.</p>
</li>
<li>重载 <code>numberOfPage</code>方法系统默认是2</li>
<li>如果不需要,就不要给对象添加约束.不要给x值添加约束</li>
<li><p><code>[self keepView:self.circle onPages:@[@(0), @(1)]];</code> 设置对象的x值的关键帧. 这句代码内部帮对象添加了x值的约束.如果你之前为x值添加其他约束,这里在运行时候回出现约束报错.同时我们只能选择对象在屏幕中左中右三个相对位置.</p>
<blockquote>
<p>注: 使对象相对于屏幕位置不动的方法   </p>
</blockquote>
<pre><code>    // 设置time即offset不变,即使相对屏幕不变
[self keepView:leimuImgHeart onPages:@[@(index-1.15),@(index-0.15), @(index-1.15)] atTimes:@[@(index-1),@(index), @(index+1)] withAttribute:IFTTTHorizontalPositionAttributeCenterX offset:0];  
</code></pre><p> Time变化引起offset变化,leimuImgHeart也得同步跟time一起变化</p>
</li>
<li><p>定义你自己的动画  </p>
<pre><code>NSLayoutConstraint * topConstraint = [NSLayoutConstraint constraintWithItem:leimuImgHeart      attribute:NSLayoutAttributeCenterY                      relatedBy:NSLayoutRelationEqual                  toItem:self.contentView
      attribute:NSLayoutAttributeTop          multiplier:1.0 constant:0.f];
[self.contentView addConstraint:topConstraint];
IFTTTConstraintMultiplierAnimation *constantAnimation = [IFTTTConstraintMultiplierAnimation animationWithSuperview:self.contentView         constraint:topConstraint                attribute:IFTTTLayoutAttributeHeight             referenceView:self.contentView];
[constantAnimation addKeyframeForTime:index-1 multiplier:-0.2f];
[constantAnimation addKeyframeForTime:index multiplier:0.3f];
[self.animator addAnimation:constantAnimation];
</code></pre></li>
</ol>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/JazzHands框架使用/" class="archive-article-date">
  	<time datetime="2016-10-19T18:09:31.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Objective-C/" style="font-size: 10px;">Objective-C</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>